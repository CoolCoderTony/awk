% vim: ts=8 sts=8 sw=4 et tw=75
\chapter{算法实验}
\label{chap:experiments_with_algorithms}
\marginpar{153}

一般而言, 理解事物如何工作的最好方式就是自己动手做一些小实验, 算法学习
就是一个典型的例子: 编写实际代码有助于弄清楚那些容易被伪码掩盖的问题.
不仅如此, 最终得到的程序是可运行的, 通过观察运行结果, 就可以知道算法的
的正确性, 而这是伪码所无法办到的.

Awk 很适合做这种测试工作. 如果某个程序使用 awk 编写, 那我们就可以把精力
集中在算法上, 而不是语言本身. 如果某个算法最终要应用到某个大型程序中,
那么先让算法能够单独地运行起来可能会更有效率. 当需要为某个算法进行调试,
测试与性能评价时, 通常需要构造一些脚手架程序, 在这一方面, awk 是一款
优秀的脚手架构造工具, 它并不关心算法本身是用什么语言实现的.

这一章讨论算法实验. 前半章描述三种排序算法, 这三种算法常常是算法课首
先要介绍的内容, 我们将使用 awk 程序对这些算法进行测试, 性能度量和
刻画. 后半章展示几种拓扑排序算法, 实现 Unix 的文件更新实用程序
\texttt{make}.

\section{排序}
\label{sec:sorting}

这一小节讨论三种著名并且很有用的算法: 插入排序, 快速排序, 以及堆排序.
插入排序非常简单, 但是只有在元素很少的情况下, 效率才足够高; 快速排序
是最好的通用排序算法之一; 堆排序可以保证即使在最坏的情况下, 也可以拥有
较高的效率. 我们对每一种算法都进行介绍, 并加以实现, 然后再用测试例程
对它们进行测试, 最后评价性能.

\subsection{插入排序}
\label{subsec:insertion_sort}
\cterm{基本概念}. 插入排序的过程类似于给一堆卡片排序: 每次从卡片堆里
拿出一张, 把它插入到合适的位置.\footnote{原文为 Insertion sort is similar
    to the method of sorting a sequence of cards by picking up the cards
    one at a time and inserting each card into its proper position in the
hand}

\cterm{实现}. 下面的代码使用插入排序对数组 \texttt{A[1]}, ...,%
\marginpar{154}%
\texttt{A[n]} 进行升序排列. 第一个动作把输入数据读取到一个数组中,
\texttt{END} 动作调用函数 \texttt{isort} 对数组进行排序, 最后输出排序
结果:
\begin{awkcode}
    # insertion sort 
        { A[NR] = $0 }
    END { isort(A, NR)
          for (i = 1; i <= NR; i++)
              print A[i]
        }

    # isort - sort A[1..n] by insertion
    function isort(A, n,    i, j, t) {
        for (i = 2; i <= n; i++)
            for (j = i; j > 1 && A[j-1] > A[j]; j--) {
                # swap A[j-1] and A[j]
                t = A[j-1]; A[j-1] = A[j]; A[j] = t
            }
    }
\end{awkcode}
\texttt{isort} 函数内的外层循环在每次迭代开始时, 数组\texttt{A} 的元素
\texttt{1} 至元素 \textit{i}\texttt{-1} 就已经处于有序状态. 内层循环每
次迭代
都把当前处于第 \textit{i} 个位置上的元素向前移动, 跳过所有比它大的元素. 
当外层循环结束时, 所有的 \textit{n} 个元素都处于有序状态.

数值或字符串都可以用这个程序进行排序. 但是当输入数据同时含有数值与字符
串时, 就要小心一点 --- 由于强制类型转换, 比较结果可能会让你感到惊讶.

如果数组 \texttt{A} 含有以下 8 个整数:
\begin{file}
    8 1 6 3 5 2 4 7
\end{file}
那么排序的过程如下所示:
\begin{file}
    8|1 6 3 5 2 4 7
    1 8|6 3 5 2 4 7
    1 6 8|3 5 2 4 7
    1 3 6 8|5 2 4 7
    1 3 5 6 8|2 4 7
    1 2 3 5 6 8|4 7
    1 2 3 4 5 6 8|7
    1 2 3 4 5 6 7 8|
\end{file}
竖线符把数组的已排序部分和未排序部分分开.

\cterm{测试}. 应该如何测试 \texttt{isort}? 我们可以每次输入一点数据,
并查看排序结果, 当然, 这样做并没有错, 可是对于任意规模的程序来说, 
这种方法不能做到详尽的测试. 第二种方案是自动生成大量的随机数集合, 
把这些集合作为 \texttt{isort} 的输入数据. 这的确是一个不错的办法,
但是还可以做得更好: 为了测试程序的薄弱环节, 我们还需要构造一些特殊
的测试用例, 用来测试边界与异常情况.
\marginpar{155} 对排序来说, 典型的边界与异常情况包括:
\begin{pattern}
\indent 序列长度为 0 \par
\indent 序列长度为 1 \par
\indent 序列包含 \textit{n} 个随机数 \par
\indent 序列包含 \textit{n} 个已排序的数 \par
\indent 序列包含 \textit{n} 个逆序排列的数 \par
\indent 序列包含 \textit{n} 个相同的数
\end{pattern}

本章的目标之一是展示如何使用 awk 来帮助测试和评价程序. 为了说明, 我们现在
要对排序例程的测试与运行结果评价过程进行自动化.

主要有两种办法来实现测试与评价过程的自动化, 每一种都有它各自的优点. 第一 
种称为 ``批处理模式'': write a program to execute a pre-planned set of
tests, exercising the sort function as suggested above.\footnote{TODO}
下面的程序可以生成测试数据并检查测试结果. 除了 \texttt{isort}, 还有其他
几个函数, 它们用来生成不同类型的数组, 以及检查排序后的数组是否是有序的.
\begin{awkcode}
    # batch test of sorting routines

    BEGIN {
        print "    0 elements"
        isort(A, 0); check(A, 0)    
        print "    1 element"
        genid(A, 1); isort(A, 1); check(A, 1)
        
        n = 10
        print "    " n " random integers"
        genrand(A, n); isort(A, n); check(A, n)
        
        print "    " n " sorted integers"
        gensort(A, n); isort(A, n); check(A, n)
        
        print "    " n " reverse-sorted integers"
        genrev(A, n); isort(A, n); check(A, n)
        
        print "    " n " identical integers"
        genid(A, n); isort(A, n); check(A, n)
    }

    function isort(A,n,     i,j,t) {
        for (i = 2; i <= n; i++)
            for (j = i; j > 1 && A[j-1] > A[j]; j--) {
                # swap A[j-1] and A[j]
                t = A[j-1]; A[j-1] = A[j]; A[j] = t
            }
    }

\end{awkcode}
\marginpar{156}
\begin{awkcode}
    # test-generation and sorting routines...

    function check(A,n,   i) {
        for (i = 1; i < n; i++)
            if (A[i] > A[i+1])
                printf("array is not sorted, element %d\n", i)
    }

    function genrand(A,n,  i) { # put n random integers in A
        for (i = 1; i <= n; i++)
            A[i] = int(n*rand())
    }

    function gensort(A,n,  i) { # put n sorted integers in A
        for (i = 1; i <= n; i++)
            A[i] = i
    }

    function genrev(A,n,  i) {  # put n reverse-sorted integers
        for (i = 1; i <= n; i++)  # in A
            A[i] = n+1-i
    }

    function genid(A,n,  i) {   # put n identical integers in A
        for (i = 1; i <= n; i++)
            A[i] = 1
    }
\end{awkcode}
